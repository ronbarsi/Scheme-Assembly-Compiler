#use "code-gen.ml";;
open Code_Gen;; 

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;


let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));; 

let make_prologue consts_tbl fvars_tbl =
  let get_const_address const = 
    let filtered = (List.filter (fun (x) -> (expr'_eq (Const' (fst x)) (Const' const))) consts_tbl) in
    let hd = (List.hd filtered) in 
    ("const_tbl+" ^ (string_of_int (fst (snd hd))))
  in
  let get_fvar_address const = 
    let filtered = (List.filter (fun (x) -> (fst x)=const) fvars_tbl) in 
    let hd = (List.hd filtered) in 
    ("fvar_tbl+8*" ^ (string_of_int (snd hd)))
  in
  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [" ^ (get_fvar_address prim)  ^ "], rax" in
  let make_constant (c, (a, s)) = s in
  
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map make_constant consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^ (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

global main
section .text
main:
    push rbp
    mov rbp,rsp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment
    ;;add rsp, 4*8
    ;;ret

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ " 

";;


let apply_push_s_lbl = "push_s" ^ (string_of_int (inc_ref lables_ref))
let apply_push_s_lbl_end = "push_s_end" ^ (string_of_int (inc_ref lables_ref))
let apply_push_x_lbl = "push_x" ^ (string_of_int (inc_ref lables_ref))
let apply_push_x_lbl_end = "push_x_end" ^ (string_of_int (inc_ref lables_ref))
let apply_reverse_s_lbl = "reverse_s" ^ (string_of_int (inc_ref lables_ref))
let apply_reverse_s_lbl_end = "reverse_s_end" ^ (string_of_int (inc_ref lables_ref))
let shift_frame_loop = "frame_loop" ^ (string_of_int (inc_ref lables_ref))
let shift_frame_loop_end = "frame_loop_end" ^ (string_of_int (inc_ref lables_ref))

let apply = "
  ;; (apply foo x1 x2 ... xn S)
  apply:
    push rbp
    mov rbp, rsp

    push SOB_NIL_ADDRESS
    
    ;;param counter
    mov r12, 0 
  
    ;; r8 <-- the list parameter of apply (s)
    GET_APPLY_LIST r8

    ;; r9 <-- reverse S (as scheme object)
      ;; if S is empty, no need to reverse.
      cmp r8, SOB_NIL_ADDRESS
      je " ^ apply_push_s_lbl_end ^ "
    CAR r9, r8
    mov r14, r9
    MAKE_PAIR(r9,r14,SOB_NIL_ADDRESS)  
    
    ;; reverse loop
    " ^ apply_reverse_s_lbl ^":
          CDR r8, r8
          cmp r8, SOB_NIL_ADDRESS
          je " ^ apply_reverse_s_lbl_end ^ "
          CAR r10, r8
          mov r14, r9
          MAKE_PAIR(r9,r10,r14)  
          jmp " ^ apply_reverse_s_lbl ^ "
    ;; reverse loop end
    " ^ apply_reverse_s_lbl_end ^ ":

    ;;push S1....Sn
    " ^ apply_push_s_lbl ^ ":
          CAR r8, r9
          push r8
          add r12, 1      
          CDR r9, r9
          cmp r9, SOB_NIL_ADDRESS
          je " ^ apply_push_s_lbl_end ^ "
          jmp " ^ apply_push_s_lbl ^ " 
    " ^ apply_push_s_lbl_end ^ ":

    ;; push X1...Xm
    mov r10, PARAM_COUNT
    sbb r10, 2
    " ^ apply_push_x_lbl ^ ":
          cmp r10, 0
          je " ^ apply_push_x_lbl_end ^ "
          mov r11, r10
          add r11, 4
          MUL8 r11
          add r11, rbp
          push qword[r11]
          add r12, 1
          sbb r10, 1
          jmp " ^ apply_push_x_lbl ^ "
    " ^ apply_push_x_lbl_end ^ ":

    ;; push new n
    push r12

    ;; push new env
    mov r15, PVAR(0)
    CLOSURE_ENV rdx, r15
    push rdx

    ;; push return address
    push qword[rbp+8]
    
    ;; rbx <-- procedure code we will want to execute
    CLOSURE_CODE rbx, r15    
    
    ;; r10 <-- backup rbp
    mov r10, qword[rbp]     

    ;; r13 <-- backup old n
    mov r13, PARAM_COUNT    
    
    ;;shift frame
    push rax
    push r8
    push r9
    
    add r12, 5
    mov rax, PARAM_COUNT
    add rax, 5
    mov rcx, 1
    
		" ^ shift_frame_loop ^":
          cmp rcx, r12
          je " ^ shift_frame_loop_end ^ "
          dec rax
          
          ;; r9 <-- rbp-rcx*8
          mov r8, rcx
          MUL8 r8     
          mov r9, rbp
          sbb r9, r8  

          mov r11, qword[r9]
          mov [rbp+8*rax], r11
          inc rcx
          jmp " ^ shift_frame_loop ^"
    " ^ shift_frame_loop_end ^ ":
    pop r9
    pop r8
		pop rax
    ;;shift frame end
    
    ;; calculate new rsp
    add r13, 5              
    shl r13, 3
    add rsp, r13
    
    ;; set rbp
    mov rbp, r10    

    ;; call code       
    jmp rbx                 

    leave
    ret
    ";;

let epilogue = "

car:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0) 
    CAR rax, rsi
    leave
    ret

cdr:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0) 
    CDR rax, rsi
    leave
    ret

set_car:
  push rbp
  mov rbp, rsp
  mov r9, PVAR(0)  ;;pair to set
  inc r9
  mov r10, PVAR(1) ;;value to set 
  mov qword[r9], r10
  mov rax, SOB_VOID_ADDRESS
  leave
  ret

set_cdr:
  push rbp
  mov rbp, rsp
  mov r9, PVAR(0)  ;;pair to set
  add r9, 9
  mov r10, PVAR(1) ;;value to set 
  mov qword[r9], r10
  mov rax, SOB_VOID_ADDRESS
  leave
  ret

cons:
  push rbp
  mov rbp, rsp
  
  mov r9, PVAR(0)  ;;arg1
  mov r10, PVAR(1)  ;;arg2
  MAKE_PAIR(rax, r9, r10)

  leave
  ret

" ^ apply;;

exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in (* infile <- the file with the scheme code *)
  let code = (file_to_string "stdlib.scm") ^ (file_to_string infile) in (* code <- concating stdlib.scm and infile *)
  let asts = string_to_asts code in (* asts <- ast tree of code, genreated by ass1 - ass3 *)
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
  let generate = Code_Gen.generate 0 0 consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> (generate ast) ^ "\n    call write_sob_if_not_void")
                           asts) in
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string ((make_prologue consts_tbl fvars_tbl)  ^
                  code_fragment ^ "\nadd rsp, 4*8\npop rbp\nret\n\n" ^ 
                    provided_primitives ^ "\n" ^ epilogue)

with Invalid_argument(x) -> raise X_missing_input_file;; 

(* 
ocaml compiler.ml foo.scm > foo.s ; nasm -g -felf64 -o foo.o foo.s ; gcc -m64 -static -o foo foo.o ; ./foo
*)
