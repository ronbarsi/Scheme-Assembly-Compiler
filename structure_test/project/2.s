
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_BOOL(0)
MAKE_BOOL(1)
MAKE_LITERAL_STRING 119, 104, 97, 116, 101, 118, 101, 114
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_STRING 116, 104, 105, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 110, 32, 101, 114, 114, 111, 114, 44, 32, 98, 117, 116, 32, 121, 111, 117, 32, 100, 111, 110, 39, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 115
MAKE_LITERAL_CHAR(0)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
section .text
main:
    push rbp
    mov rbp,rsp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    jmp code_fragment
    ;;add rsp, 4*8
    ;;ret

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl+8*0], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl+8*1], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl+8*2], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl+8*3], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl+8*4], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl+8*5], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_vector)
    mov [fvar_tbl+8*6], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl+8*7], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl+8*8], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl+8*9], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl+8*10], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl+8*11], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl+8*12], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl+8*13], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_length)
    mov [fvar_tbl+8*14], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_ref)
    mov [fvar_tbl+8*15], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, vector_set)
    mov [fvar_tbl+8*16], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_vector)
    mov [fvar_tbl+8*17], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl+8*18], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl+8*19], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl+8*20], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl+8*21], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl+8*22], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl+8*23], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl+8*24], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl+8*25], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl+8*26], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl+8*27], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
    mov [fvar_tbl+8*28], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
    mov [fvar_tbl+8*29], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl+8*30], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl+8*31], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
    mov [fvar_tbl+8*32], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
    mov [fvar_tbl+8*33], rax 

;;Generate Def'(VarFree(append), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cons):

mov rax, FVAR(32)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode25)
        jmp Lcont26
        
          Lcode25:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*4          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 4, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode21)
        jmp Lcont22
        
          Lcode21:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end24
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt23:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt23
        Lopt_end24:
        
            ;;end adjust stack
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(args,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+1

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode19)
        jmp Lcont20
        
          Lcode19:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(f, 0)),exp):

;;Generate Box'(Var'(VarParam(f,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(f,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode17)
        jmp Lcont18
        
          Lcode17:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(args,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse10

;;generate dit:

;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

jmp IFexit9
Lelse10:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+4)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 4, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*2          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 2, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode15)
        jmp Lcont16
        
          Lcode15:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(g, 0)),exp):

;;Generate Box'(Var'(VarParam(g,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(g,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+5)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 5, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode13)
        jmp Lcont14
        
          Lcode13:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,4,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*4]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse12

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(args,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,4,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*4]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(args,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(car,4,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*4]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(f,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit11
Lelse12:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,4,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*4]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(g,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,4,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*4]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(cons,4,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*4]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit11:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont14:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(g,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate BoxGet'(var):

;;Generate VarParam(g,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont16:

;;end of Generate LambdaSimple'(args,body)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit9:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont18:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(f,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate BoxGet'(var):

;;Generate VarParam(f,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont20:

;;end of Generate LambdaSimple'(args,body)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont22:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont26:

;;end of Generate LambdaSimple'(args,body)


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*34], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(append), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(zero?), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode29)
        jmp Lcont30
        
          Lcode29:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode27)
        jmp Lcont28
        
          Lcode27:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(=,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont28:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont30:

;;end of Generate LambdaSimple'(args,body)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*35], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(zero?), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(list), value):

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode31)
        jmp Lcont32
        
          Lcode31:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end34
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt33:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt33
        Lopt_end34:
        
            ;;end adjust stack
            ;;body:
            ;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


            ;;end body   
            leave
            ret
          Lcont32:

;;end of Generate LambdaSimple'(args,body)


              mov [fvar_tbl+8*36], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(list), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(list?), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(pair?):

mov rax, FVAR(3)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode40)
        jmp Lcont41
        
          Lcode40:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*3          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 3, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode38)
        jmp Lcont39
        
          Lcode38:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Or'(seq):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit35
;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(pair?,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse37

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,0,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarFree(list?):

mov rax, FVAR(37)

;;end of Generate VarFree 


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit36
Lelse37:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit36:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit35
ORexit35:

;;end of Generate Or'(seq)


            ;;end body   
            leave
            ret
          Lcont39:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont41:

;;end of Generate LambdaSimple'(args,body)


          push 3
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*37], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(list?), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(length), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(+):

mov rax, FVAR(22)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(pair?):

mov rax, FVAR(3)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode52)
        jmp Lcont53
        
          Lcode52:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*4          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 4, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode50)
        jmp Lcont51
        
          Lcode50:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode48)
        jmp Lcont49
        
          Lcode48:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 1)),exp):

;;Generate Box'(Var'(VarParam(loop,1))):


          mov r8, qword[rbp+8*(4+1)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,1)))


            mov qword[rbp+8*(4+1)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(count, 0)),exp):

;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*2          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 2, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode46)
        jmp Lcont47
        
          Lcode46:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse43

;;generate dit:

;;Generate VarParam(count,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

jmp IFexit42
Lelse43:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(pair?,2,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse45

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(count,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate VarBound(+,2,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,2,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit44
Lelse45:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

IFexit44:

;;end of Generate If'(cond,dit,dif)

IFexit42:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont47:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(x,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarParam(loop,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont49:

;;end of Generate LambdaSimple'(args,body)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont51:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont53:

;;end of Generate LambdaSimple'(args,body)


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*38], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(length), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(make-string), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(length):

mov rax, FVAR(38)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(make-string):

mov rax, FVAR(13)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode62)
        jmp Lcont63
        
          Lcode62:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*5          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 5, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode58)
        jmp Lcont59
        
          Lcode58:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 1
        je Lopt_end61
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 1               ;; rcx <- n-m

        Lopt60:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt60
        Lopt_end61:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse55

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+116

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(make-string,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit54
Lelse55:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(length,0,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate VarBound(=,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse57

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,0,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(make-string,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit56
Lelse57:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

IFexit56:

;;end of Generate If'(cond,dit,dif)

IFexit54:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont59:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont63:

;;end of Generate LambdaSimple'(args,body)


          push 5
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*13], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(make-string), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(make-vector), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(make-vector):

mov rax, FVAR(17)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(length):

mov rax, FVAR(38)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode72)
        jmp Lcont73
        
          Lcode72:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*4          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 4, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode68)
        jmp Lcont69
        
          Lcode68:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 1
        je Lopt_end71
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 1               ;; rcx <- n-m

        Lopt70:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt70
        Lopt_end71:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse65

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(make-vector,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit64
Lelse65:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(length,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse67

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,0,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(make-vector,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit66
Lelse67:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

IFexit66:

;;end of Generate If'(cond,dit,dif)

IFexit64:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont69:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont73:

;;end of Generate LambdaSimple'(args,body)


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*17], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(make-vector), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(not), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(eq?):

mov rax, FVAR(21)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode78)
        jmp Lcont79
        
          Lcode78:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode76)
        jmp Lcont77
        
          Lcode76:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(eq?,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse75

;;generate dit:

;;Generate Const':

mov rax, const_tbl+4

;;end of Generate Const' 

jmp IFexit74
Lelse75:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit74:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont77:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont79:

;;end of Generate LambdaSimple'(args,body)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*39], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(not), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(number?), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(integer?):

mov rax, FVAR(2)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(float?):

mov rax, FVAR(1)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode83)
        jmp Lcont84
        
          Lcode83:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*2          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 2, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode81)
        jmp Lcont82
        
          Lcode81:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Or'(seq):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(float?,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit80
;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(integer?,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit80
ORexit80:

;;end of Generate Or'(seq)


            ;;end body   
            leave
            ret
          Lcont82:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont84:

;;end of Generate LambdaSimple'(args,body)


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*40], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(number?), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(map), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(apply):

mov rax, FVAR(33)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(cons):

mov rax, FVAR(32)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode107)
        jmp Lcont108
        
          Lcode107:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*5          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 5, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode103)
        jmp Lcont104
        
          Lcode103:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 2
        je Lopt_end106
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 2               ;; rcx <- n-m

        Lopt105:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt105
        Lopt_end106:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(more,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse86

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*3          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 3, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode93)
        jmp Lcont94
        
          Lcode93:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode91)
        jmp Lcont92
        
          Lcode91:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(map1, 0)),exp):

;;Generate Box'(Var'(VarParam(map1,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(map1,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+4)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 4, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode89)
        jmp Lcont90
        
          Lcode89:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,3,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse88

;;generate dit:

;;Generate Const':

mov rax, const_tbl+1

;;end of Generate Const' 

jmp IFexit87
Lelse88:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,3,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(map1,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,3,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(f,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(cons,3,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit87:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont90:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(map1,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(ls,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarParam(map1,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont92:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont94:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit85
Lelse86:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(more,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(ls,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*3          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 3, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode101)
        jmp Lcont102
        
          Lcode101:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*2          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 2, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode99)
        jmp Lcont100
        
          Lcode99:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(map-more, 0)),exp):

;;Generate Box'(Var'(VarParam(map-more,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(map-more,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+4)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 4, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode97)
        jmp Lcont98
        
          Lcode97:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,3,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse96

;;generate dit:

;;Generate Const':

mov rax, const_tbl+1

;;end of Generate Const' 

jmp IFexit95
Lelse96:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(more,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(cdr,3,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarFree(map):

mov rax, FVAR(41)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,3,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(map-more,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(more,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(car,3,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarFree(map):

mov rax, FVAR(41)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(ls,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,3,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(f,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(apply,3,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 3
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(cons,3,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*3]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit95:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont98:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(map-more,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(more,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(ls,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarParam(map-more,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont100:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont102:

;;end of Generate LambdaSimple'(args,body)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit85:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont104:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont108:

;;end of Generate LambdaSimple'(args,body)


          push 5
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*41], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(map), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(list->vector), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(+):

mov rax, FVAR(22)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(length):

mov rax, FVAR(38)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(make-vector):

mov rax, FVAR(17)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(pair?):

mov rax, FVAR(3)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode119)
        jmp Lcont120
        
          Lcode119:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*7          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 7, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode117)
        jmp Lcont118
        
          Lcode117:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode115)
        jmp Lcont116
        
          Lcode115:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode113)
        jmp Lcont114
        
          Lcode113:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse110

;;generate dit:

;;Generate VarParam(vec,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

jmp IFexit109
Lelse110:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(pair?,2,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse112

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(count,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate VarBound(+,2,6):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*6]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Seq'(seq):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,2,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(count,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(vec,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarFree(vector-set!):

mov rax, FVAR(16)

;;end of Generate VarFree 


          push 3
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

;;Generate VarParam(vec,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

;;end of Generate Seq'(seq)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,2,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 3                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 7          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit111
Lelse112:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

IFexit111:

;;end of Generate If'(cond,dit,dif)

IFexit109:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont114:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(lst,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(length,1,5):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*5]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(make-vector,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(lst,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 3                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 7          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont116:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont118:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont120:

;;end of Generate LambdaSimple'(args,body)


          push 7
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*42], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(list->vector), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(vector->list), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(-):

mov rax, FVAR(24)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(vector-length):

mov rax, FVAR(14)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(cons):

mov rax, FVAR(32)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(vector-ref):

mov rax, FVAR(15)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(<):

mov rax, FVAR(26)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode129)
        jmp Lcont130
        
          Lcode129:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*5          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 5, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode127)
        jmp Lcont128
        
          Lcode127:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode125)
        jmp Lcont126
        
          Lcode125:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode123)
        jmp Lcont124
        
          Lcode123:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(count,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(<,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse122

;;generate dit:

;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

jmp IFexit121
Lelse122:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(count,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(-,2,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(count,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(vec,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(vector-ref,2,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(cons,2,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(vec,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 3                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 7          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit121:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont124:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(vec,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(vector-length,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(-,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+1

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(vec,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 3                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 7          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont126:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont128:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont130:

;;end of Generate LambdaSimple'(args,body)


          push 5
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*43], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(vector->list), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(vector), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(list->vector):

mov rax, FVAR(42)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode135)
        jmp Lcont136
        
          Lcode135:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode131)
        jmp Lcont132
        
          Lcode131:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end134
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt133:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt133
        Lopt_end134:
        
            ;;end adjust stack
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(list->vector,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont132:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont136:

;;end of Generate LambdaSimple'(args,body)


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*44], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(vector), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(+), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(apply):

mov rax, FVAR(33)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(+):

mov rax, FVAR(22)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode145)
        jmp Lcont146
        
          Lcode145:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*5          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 5, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode143)
        jmp Lcont144
        
          Lcode143:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode139)
        jmp Lcont140
        
          Lcode139:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end142
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt141:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt141
        Lopt_end142:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse138

;;generate dit:

;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

jmp IFexit137
Lelse138:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

push rax
                ;;end of generate arg
;;Generate VarBound(apply,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(+,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit137:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont140:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate BoxGet'(var):

;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont144:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont146:

;;end of Generate LambdaSimple'(args,body)


          push 5
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*22], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(+), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(*), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(apply):

mov rax, FVAR(33)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(*):

mov rax, FVAR(23)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode155)
        jmp Lcont156
        
          Lcode155:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*5          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 5, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode153)
        jmp Lcont154
        
          Lcode153:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode149)
        jmp Lcont150
        
          Lcode149:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end152
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt151:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt151
        Lopt_end152:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse148

;;generate dit:

;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

jmp IFexit147
Lelse148:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

push rax
                ;;end of generate arg
;;Generate VarBound(apply,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(*,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit147:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont150:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate BoxGet'(var):

;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont154:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont156:

;;end of Generate LambdaSimple'(args,body)


          push 5
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*23], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(*), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(-), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(length):

mov rax, FVAR(38)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(apply):

mov rax, FVAR(33)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(+):

mov rax, FVAR(22)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(-):

mov rax, FVAR(24)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode173)
        jmp Lcont174
        
          Lcode173:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*7          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 7, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode171)
        jmp Lcont172
        
          Lcode171:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode159)
        jmp Lcont160
        
          Lcode159:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end162
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt161:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt161
        Lopt_end162:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse158

;;generate dit:

;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

jmp IFexit157
Lelse158:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,6):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*6]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

push rax
                ;;end of generate arg
;;Generate VarBound(apply,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(-,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit157:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont160:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode167)
        jmp Lcont168
        
          Lcode167:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end170
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt169:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt169
        Lopt_end170:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse164

;;generate dit:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

jmp IFexit163
Lelse164:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(length,1,5):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*5]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse166

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate VarBound(-,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit165
Lelse166:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,6):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*6]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)

push rax
                ;;end of generate arg
;;Generate VarBound(apply,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(+,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit165:

;;end of Generate If'(cond,dit,dif)

IFexit163:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont168:

;;end of Generate LambdaSimple'(args,body)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont172:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont174:

;;end of Generate LambdaSimple'(args,body)


          push 7
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*24], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(-), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(/), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(length):

mov rax, FVAR(38)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(apply):

mov rax, FVAR(33)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(*):

mov rax, FVAR(23)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(/):

mov rax, FVAR(25)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode183)
        jmp Lcont184
        
          Lcode183:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*7          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 7, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode179)
        jmp Lcont180
        
          Lcode179:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end182
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt181:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt181
        Lopt_end182:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse176

;;generate dit:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

jmp IFexit175
Lelse176:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(length,0,5):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*5]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse178

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate VarBound(/,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit177
Lelse178:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,0,6):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*6]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(*,0,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(apply,0,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(num,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(/,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit177:

;;end of Generate If'(cond,dit,dif)

IFexit175:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont180:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont184:

;;end of Generate LambdaSimple'(args,body)


          push 7
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*25], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(/), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(=), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode199)
        jmp Lcont200
        
          Lcode199:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*4          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 4, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode197)
        jmp Lcont198
        
          Lcode197:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode189)
        jmp Lcont190
        
          Lcode189:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse186

;;generate dit:

;;Generate Const':

mov rax, const_tbl+4

;;end of Generate Const' 

jmp IFexit185
Lelse186:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(element,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(=,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse188

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit187
Lelse188:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit187:

;;end of Generate If'(cond,dit,dif)

IFexit185:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont190:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode193)
        jmp Lcont194
        
          Lcode193:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end196
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt195:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt195
        Lopt_end196:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse192

;;generate dit:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

jmp IFexit191
Lelse192:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit191:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont194:

;;end of Generate LambdaSimple'(args,body)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont198:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont200:

;;end of Generate LambdaSimple'(args,body)


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*27], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(=), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(<), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(<):

mov rax, FVAR(26)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode215)
        jmp Lcont216
        
          Lcode215:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*4          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 4, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode213)
        jmp Lcont214
        
          Lcode213:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode205)
        jmp Lcont206
        
          Lcode205:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse202

;;generate dit:

;;Generate Const':

mov rax, const_tbl+4

;;end of Generate Const' 

jmp IFexit201
Lelse202:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(element,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(<,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse204

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit203
Lelse204:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit203:

;;end of Generate If'(cond,dit,dif)

IFexit201:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont206:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode209)
        jmp Lcont210
        
          Lcode209:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end212
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt211:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt211
        Lopt_end212:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse208

;;generate dit:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

jmp IFexit207
Lelse208:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit207:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont210:

;;end of Generate LambdaSimple'(args,body)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont214:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont216:

;;end of Generate LambdaSimple'(args,body)


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*26], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(<), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(>), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(not):

mov rax, FVAR(39)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(<):

mov rax, FVAR(26)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(null?):

mov rax, FVAR(4)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode232)
        jmp Lcont233
        
          Lcode232:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*6          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 6, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode230)
        jmp Lcont231
        
          Lcode230:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode222)
        jmp Lcont223
        
          Lcode222:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse218

;;generate dit:

;;Generate Const':

mov rax, const_tbl+4

;;end of Generate Const' 

jmp IFexit217
Lelse218:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Or'(seq):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(element,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(<,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit221
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(element,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(=,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit221
ORexit221:

;;end of Generate Or'(seq)

push rax
                ;;end of generate arg
;;Generate VarBound(not,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse220

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,5):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*5]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit219
Lelse220:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit219:

;;end of Generate If'(cond,dit,dif)

IFexit217:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont223:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate LambdaOpt'(args,opt,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode226)
        jmp Lcont227
        
          Lcode226:
            push rbp
            mov rbp, rsp
            ;;adjust stack
            
        ;;PSAUDO CODE:
        ;; n <- [rbp +8*3]
        ;; m <- Length(args)
        ;;
        ;; while (n-m > 0)
        ;;    [rbp+8*(4+n)] <- Pair([rbp+8*(4+n)],[rbp+8*(5+n)])
        ;;    n--

        mov r11, qword[rbp+8*3]   ;; r10 <- n
        cmp r11, 0
        je Lopt_end229
 
        dec r11                   ;; r11 <- n-1

        mov rcx, qword[rbp+8*3]   ;; rcx <- n
        sbb rcx, 0               ;; rcx <- n-m

        Lopt228:
          LAMBDA_OPT_MAKE_PAIRS r11, r12, 4
          mov r14, [r12]

          LAMBDA_OPT_MAKE_PAIRS r11, r13, 5
          mov r13, [r13]

          MAKE_PAIR(r9, r14, r13)
          mov [r12], r9
          dec r11
          dec rcx
          jnz Lopt228
        Lopt_end229:
        
            ;;end adjust stack
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(null?,1,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse225

;;generate dit:

;;Generate Const':

mov rax, const_tbl+50

;;end of Generate Const' 

jmp IFexit224
Lelse225:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,5):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*5]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(lst,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit224:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont227:

;;end of Generate LambdaSimple'(args,body)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont231:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont233:

;;end of Generate LambdaSimple'(args,body)


          push 6
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*45], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(>), value)


    call write_sob_if_not_void

;;Generate Def'(VarFree(equal?), value):

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarFree(-):

mov rax, FVAR(24)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(char->integer):

mov rax, FVAR(19)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(cdr):

mov rax, FVAR(29)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(car):

mov rax, FVAR(28)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(eq?):

mov rax, FVAR(21)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(vector?):

mov rax, FVAR(6)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(string?):

mov rax, FVAR(7)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(char?):

mov rax, FVAR(5)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(pair?):

mov rax, FVAR(3)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(float?):

mov rax, FVAR(1)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(integer?):

mov rax, FVAR(2)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(vector-length):

mov rax, FVAR(14)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(vector-ref):

mov rax, FVAR(15)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(string-ref):

mov rax, FVAR(11)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(string-length):

mov rax, FVAR(10)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(not):

mov rax, FVAR(39)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(=):

mov rax, FVAR(27)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarFree(<):

mov rax, FVAR(26)

;;end of Generate VarFree 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+0)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 0, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*0          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 0, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode277)
        jmp Lcont278
        
          Lcode277:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*18          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 18, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode244)
        jmp Lcont245
        
          Lcode244:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+23

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*4          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 4, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode242)
        jmp Lcont243
        
          Lcode242:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Seq'(seq):

;;Generate Set'(Var'(VarParam(loop, 0)),exp):

;;Generate Box'(Var'(VarParam(loop,0))):


          mov r8, qword[rbp+8*(4+0)] ;;save the address of var at r8
          MALLOC r9, 8                ;;allocate 8 bytes (save address in r9) for address of sob
          mov qword[r9], r8           ;;put the value of r8 (the saved value of var) inside the adress that allocated at r9
          mov rax, r9
          ;;end of Generate Box'(Var'(VarParam(loop,0)))


            mov qword[rbp+8*(4+0)], rax
            mov rax, SOB_VOID_ADDRESS

;;end of Generate Set(VarParam) 

;;Generate Seq'(seq):

;;Generate BoxSet'(var, exp):

;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+3)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 3, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode238)
        jmp Lcont239
        
          Lcode238:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+32

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(index,3):

mov rax, qword[rbp+8*(4+3)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(<,2,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse235

;;generate dit:

;;Generate Const':

mov rax, const_tbl+4

;;end of Generate Const' 

jmp IFexit234
Lelse235:
;;generate dif:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(index,3):

mov rax, qword[rbp+8*(4+3)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(container-2,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarParam(container-ref-fun,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(index,3):

mov rax, qword[rbp+8*(4+3)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(container-1,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarParam(container-ref-fun,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarFree(equal?):

mov rax, FVAR(46)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse237

;;generate dit:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(index,3):

mov rax, qword[rbp+8*(4+3)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(-,2,17):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*2]
            mov rax, qword[rax+8*17]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(container-ref-fun,2):

mov rax, qword[rbp+8*(4+2)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(container-2,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(container-1,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarBound(loop,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 4                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 8          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

jmp IFexit236
Lelse237:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit236:

;;end of Generate If'(cond,dit,dif)

IFexit234:

;;end of Generate If'(cond,dit,dif)


            ;;end body   
            leave
            ret
          Lcont239:

;;end of Generate LambdaSimple'(args,body)

push rax
;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 


          pop qword[rax]
          mov rax, SOB_VOID_ADDRESS

;;end of Generate BoxSet'(var, exp)

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(container-2,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(container-size-fun,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(container-1,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(container-size-fun,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(=,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(not,1,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse241

;;generate dit:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

jmp IFexit240
Lelse241:
;;generate dif:

;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Const':

mov rax, const_tbl+41

;;end of Generate Const' 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(container-1,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate VarBound(container-size-fun,0,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(-,1,17):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*17]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(container-ref-fun,0,2):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*2]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(container-2,0,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(container-1,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;Generate BoxGet'(var):

;;Generate VarParam(loop,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

mov rax, qword[rax]

;;end of Generate BoxGet'(var)


          push 4                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 8          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)

IFexit240:

;;end of Generate If'(cond,dit,dif)

;;end of Generate Seq'(seq)

;;end of Generate Seq'(seq)


            ;;end body   
            leave
            ret
          Lcont243:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont245:

;;end of Generate LambdaSimple'(args,body)

push rax
                ;;end of generate arg
;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+1)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 1, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*18          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 18, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode275)
        jmp Lcont276
        
          Lcode275:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate LambdaSimple'(args,body):


        ;;allocate new env: |new_env| = 1+|old_env|
        MALLOC r8, 8*(1+2)       ;;r8 = ext_env
        mov r9, qword[rbp+8*2]    ;;r9 = old_env

        EXT_ENV_STEP_1 2, r8, r9 ;;ext_env[i+1] <-- old_env[i]

        MALLOC r12, 8*1          ;;r12 = target array for ext_env[0]

        EXT_ENV_STEP_2 1, r12    ;;ext_env[0] <-- qword[rbp+8*i]

        mov [r8], r12

        ;;PSAUDO CODE:
        ;; for i = 0 to |old_env|:
        ;;    new_env[i+1] <-- old_env[i]  (* every cell is 8 bytes, address of array of parameters! *)
        ;;
        ;; allocate array in size n (rbp+ + 8*3) - the amount of paramaters of the current stack
        ;; for i = 0 to n-1:
        ;;    new_env[0] <-- qword[rbp+8*i]
        ;;
        ;; finally - save the addres of new_env at r8!!!
        
        MAKE_CLOSURE(rax,r8,Lcode273)
        jmp Lcont274
        
          Lcode273:
            push rbp
            mov rbp, rsp
            ;;body:
            ;;Generate Or'(seq):

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(integer?,1,7):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*7]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse248

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(integer?,1,7):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*7]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse250

;;generate dit:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(=,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

jmp IFexit249
Lelse250:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit249:

;;end of Generate If'(cond,dit,dif)

jmp IFexit247
Lelse248:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit247:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(float?,1,8):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*8]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse252

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(float?,1,8):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*8]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse254

;;generate dit:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(=,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

jmp IFexit253
Lelse254:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit253:

;;end of Generate If'(cond,dit,dif)

jmp IFexit251
Lelse252:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit251:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(pair?,1,9):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*9]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse256

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(pair?,1,9):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*9]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse258

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,14):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*14]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(car,1,14):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*14]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarFree(equal?):

mov rax, FVAR(46)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse260

;;generate dit:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,15):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*15]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(cdr,1,15):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*15]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarFree(equal?):

mov rax, FVAR(46)

;;end of Generate VarFree 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

jmp IFexit259
Lelse260:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit259:

;;end of Generate If'(cond,dit,dif)

jmp IFexit257
Lelse258:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit257:

;;end of Generate If'(cond,dit,dif)

jmp IFexit255
Lelse256:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit255:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(char?,1,10):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*10]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse262

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(char?,1,10):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*10]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse264

;;generate dit:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(char->integer,1,16):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*16]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;generate arg:
;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(char->integer,1,16):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*16]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

push rax
                ;;end of generate arg
;;Generate VarBound(=,1,1):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*1]

;;end of Generate VarBound 


          push 2
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

jmp IFexit263
Lelse264:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit263:

;;end of Generate If'(cond,dit,dif)

jmp IFexit261
Lelse262:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit261:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(string?,1,11):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*11]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse266

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(string?,1,11):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*11]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse268

;;generate dit:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(string-length,1,3):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*3]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(string-ref,1,4):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*4]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(compare-composite,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

jmp IFexit267
Lelse268:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit267:

;;end of Generate If'(cond,dit,dif)

jmp IFexit265
Lelse266:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit265:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(vector?,1,12):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*12]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse270

;;generate dit:

;;Generate If'(cond,dit,dif):

;;generate condition:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(vector?,1,12):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*12]

;;end of Generate VarBound 


          push 1
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

cmp rax, SOB_FALSE_ADDRESS
          je Lelse272

;;generate dit:

;;Generate Applic'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarBound(vector-length,1,6):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*6]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarBound(vector-ref,1,5):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*5]

;;end of Generate VarBound 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(compare-composite,0,0):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*0]
            mov rax, qword[rax+8*0]

;;end of Generate VarBound 


          push 4
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)

jmp IFexit271
Lelse272:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit271:

;;end of Generate If'(cond,dit,dif)

jmp IFexit269
Lelse270:
;;generate dif:

;;Generate Const':

mov rax, const_tbl+2

;;end of Generate Const' 

IFexit269:

;;end of Generate If'(cond,dit,dif)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
;;Generate ApplicTP'(rator, rands):

push SOB_NIL_ADDRESS

;;generate arg:
;;Generate VarParam(y,1):

mov rax, qword[rbp+8*(4+1)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;generate arg:
;;Generate VarParam(x,0):

mov rax, qword[rbp+8*(4+0)]

;;end of Generate VarParam 

push rax
                ;;end of generate arg
;;Generate VarBound(eq?,1,13):


            mov rax, qword[rbp+8*2]
            mov rax, qword[rax+8*1]
            mov rax, qword[rax+8*13]

;;end of Generate VarBound 


          push 2                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 6          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


          cmp rax, SOB_FALSE_ADDRESS
          jne ORexit246
ORexit246:

;;end of Generate Or'(seq)


            ;;end body   
            leave
            ret
          Lcont274:

;;end of Generate LambdaSimple'(args,body)


            ;;end body   
            leave
            ret
          Lcont276:

;;end of Generate LambdaSimple'(args,body)


          push 1                 ;; push n
          CLOSURE_ENV rbx, rax    ;; rbx <-- rax+1 (Closure.env) 
          push rbx                ;; push env
          push qword[rbp+8]       ;; push return address
          
          CLOSURE_CODE rbx, rax   ;; rbx <-- rax+9 (Closure.code) 
          mov r10, qword[rbp]     ;; r10 <-- backup rbp
          mov r13, PARAM_COUNT    ;; r13 <--backup old n
          
          SHIFT_FRAME 5          ;; overwrite old frame

          add r13, 5              ;; calculate new rsp
          MUL8 r13                ;; calculate new rsp
          add rsp, r13            ;; set new rsp

          mov rbp, r10            ;; set rbp
          jmp rbx                 ;; call code
          ;;end of Generate ApplicTP'(rator, rands)


            ;;end body   
            leave
            ret
          Lcont278:

;;end of Generate LambdaSimple'(args,body)


          push 18
          CLOSURE_ENV rbx, rax  ;;rax contains closure object, CLOSURE_ENV preform: rbx <-- rax+1    i.e the address to the env
          push rbx
          CLOSURE_CODE rbx, rax ;;rax contains closure object, CLOSURE_CODE preform: rax <-- rax+1+8    i.e the address to the code
          call rbx
          
          add rsp, 8*1    ;; pop env
          pop rbx         ;; pop arg count
          add rbx, 1      ;; add 1 for magic
          shl rbx, 3      ;; rbx = rbx * 8
          add rsp, rbx    ;; pop args
          

;;end of Generate Applic'(rator, rands)


              mov [fvar_tbl+8*46], rax
              mov rax, SOB_VOID_ADDRESS

;;end of Generate Def'(VarFree(equal?), value)


    call write_sob_if_not_void

;;Generate Const':

mov rax, const_tbl+1

;;end of Generate Const' 


    call write_sob_if_not_void
add rsp, 4*8
pop rbp
ret

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_vector:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_VECTOR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

vector_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    VECTOR_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

vector_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rax, [rsi]

    leave
    ret

vector_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    VECTOR_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 3
    add rsi, rdi

    mov rdi, PVAR(2)
    mov [rsi], rdi
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_vector:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    

    MAKE_VECTOR rax, rsi, rdi

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

.loop:
    cmp rcx, 0
    je .end
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    dec rcx
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret




car:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0) 
    CAR rax, rsi
    leave
    ret

cdr:
    push rbp
    mov rbp, rsp
    mov rsi, PVAR(0) 
    CDR rax, rsi
    leave
    ret

set_car:
  push rbp
  mov rbp, rsp
  mov r9, PVAR(0)  ;;pair to set
  inc r9
  mov r10, PVAR(1) ;;value to set 
  mov qword[r9], r10
  mov rax, SOB_VOID_ADDRESS
  leave
  ret

set_cdr:
  push rbp
  mov rbp, rsp
  mov r9, PVAR(0)  ;;pair to set
  add r9, 9
  mov r10, PVAR(1) ;;value to set 
  mov qword[r9], r10
  mov rax, SOB_VOID_ADDRESS
  leave
  ret

cons:
  push rbp
  mov rbp, rsp
  
  mov r9, PVAR(0)  ;;arg1
  mov r10, PVAR(1)  ;;arg2
  MAKE_PAIR(rax, r9, r10)

  leave
  ret


  ;; (apply foo x1 x2 ... xn S)
  apply:
    push rbp
    mov rbp, rsp

    push SOB_NIL_ADDRESS
    
    ;;param counter
    mov r12, 0 
  
    ;; r8 <-- the list parameter of apply (s)
    GET_APPLY_LIST r8

    ;; r9 <-- reverse S (as scheme object)
      ;; if S is empty, no need to reverse.
      cmp r8, SOB_NIL_ADDRESS
      je push_s_end2
    CAR r9, r8
    mov r14, r9
    MAKE_PAIR(r9,r14,SOB_NIL_ADDRESS)  
    
    ;; reverse loop
    reverse_s5:
          CDR r8, r8
          cmp r8, SOB_NIL_ADDRESS
          je reverse_s_end6
          CAR r10, r8
          mov r14, r9
          MAKE_PAIR(r9,r10,r14)  
          jmp reverse_s5
    ;; reverse loop end
    reverse_s_end6:

    ;;push S1....Sn
    push_s1:
          CAR r8, r9
          push r8
          add r12, 1      
          CDR r9, r9
          cmp r9, SOB_NIL_ADDRESS
          je push_s_end2
          jmp push_s1 
    push_s_end2:

    ;; push X1...Xm
    mov r10, PARAM_COUNT
    sbb r10, 2
    push_x3:
          cmp r10, 0
          je push_x_end4
          mov r11, r10
          add r11, 4
          MUL8 r11
          add r11, rbp
          push qword[r11]
          add r12, 1
          sbb r10, 1
          jmp push_x3
    push_x_end4:

    ;; push new n
    push r12

    ;; push new env
    mov r15, PVAR(0)
    CLOSURE_ENV rdx, r15
    push rdx

    ;; push return address
    push qword[rbp+8]
    
    ;; rbx <-- procedure code we will want to execute
    CLOSURE_CODE rbx, r15    
    
    ;; r10 <-- backup rbp
    mov r10, qword[rbp]     

    ;; r13 <-- backup old n
    mov r13, PARAM_COUNT    
    
    ;;shift frame
    push rax
    push r8
    push r9
    
    add r12, 5
    mov rax, PARAM_COUNT
    add rax, 5
    mov rcx, 1
    
		frame_loop7:
          cmp rcx, r12
          je frame_loop_end8
          dec rax
          
          ;; r9 <-- rbp-rcx*8
          mov r8, rcx
          MUL8 r8     
          mov r9, rbp
          sbb r9, r8  

          mov r11, qword[r9]
          mov [rbp+8*rax], r11
          inc rcx
          jmp frame_loop7
    frame_loop_end8:
    pop r9
    pop r8
		pop rax
    ;;shift frame end
    
    ;; calculate new rsp
    add r13, 5              
    shl r13, 3
    add rsp, r13
    
    ;; set rbp
    mov rbp, r10    

    ;; call code       
    jmp rbx                 

    leave
    ret
    